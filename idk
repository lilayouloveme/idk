#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/ipc.h>
#include<sys/shm.h>
#include<sys/sem.h>
#include<sys/time.h>
#include<sys/signal.h>
#include<sys/wait.h>
#include<string.h>
#include<time.h>
#include<ctype.h>
union semun{int val;struct semid_ds*buf;unsigned short*array;struct seminfo*__buf;};
static int setup_interval_timer(int);static int setup_interrupt(void);static void free_shared_memory(void);static void free_shared_memory_and_abort(int);static void print_help_message(char*,int,char*,int,int);static int is_required_argument(char);static void print_required_argument_message(char);static int get_clock_shared_segment_size(void);static void attach_to_shared_memory(void);static int initialize_binary_semaphore(int);static int allocate_binary_semaphore(key_t,int);static int deallocate_binary_semaphore(int);static void fork_and_exec_children(int);static void fork_and_exec_child(void);static void get_shared_memory(void);static void empty_message(void);
static int clock_segment_id;static int*clock_shared_memory;static int message_segment_id;static int*message_shared_memory;static int sem_id;
int num_slaves_completed=0;const int MAX_SLAVES=100;FILE*fp;const int NANO_SECONDS_PER_SECOND=1000000000;
void handle_child_termination(int signum){int status;pid_t pid=wait(&status);fprintf(fp,"[Master] Child %d is terminating at my time %d:%d because it reached %d:%d in slave\n",pid,*clock_shared_memory,*(clock_shared_memory+1),*(message_shared_memory),*(message_shared_memory+1));empty_message();fork_and_exec_child();num_slaves_completed++;}
int main(int argc,char*argv[]){int help_flag=0;int max_inital_slaves=5;char*log_file="oss.out";int max_run_time=20;int max_sim_time=2;opterr=0;int c;while((c=getopt(argc,argv,"hs:l:t:m:"))!=-1){switch(c){case'h':help_flag=1;break;case's':max_inital_slaves=atoi(optarg);break;case'l':log_file=optarg;break;case't':max_run_time=atoi(optarg);break;case'm':max_sim_time=atoi(optarg);break;case'?':if(is_required_argument(optopt)){print_required_argument_message(optopt);}else if(isprint(optopt)){fprintf(stderr,"Unknown option `-%c'.\n",optopt);}else{fprintf(stderr,"Unknown option character `\\x%x'.\n",optopt);}return 1;default:abort();}}if(help_flag){print_help_message(argv[0],max_inital_slaves,log_file,max_run_time,max_sim_time);return 0;}if(max_inital_slaves<1||max_run_time<1||max_sim_time<1){fprintf(stderr,"Invalid argument\n");return 0;}if(setup_interrupt()==-1){perror("Failed to set up handler for SIGPROF");return 1;}if(setup_interval_timer(max_run_time)==-1){perror("Failed to set up the ITIMER_PROF interval timer");return 1;}fp=fopen(log_file,"w+");if(fp==NULL){perror("Failed to open log file");return 1;}signal(SIGINT,free_shared_memory_and_abort);signal(SIGCHLD,handle_child_termination);get_shared_memory();sem_id=allocate_binary_semaphore(IPC_PRIVATE,IPC_CREAT|IPC_EXCL|0600);attach_to_shared_memory();empty_message();if(initialize_binary_semaphore(sem_id)==-1){perror("Failed to initialize binary semaphore");return 1;}fork_and_exec_children(max_inital_slaves);while(1){if(*(clock_shared_memory+1)==NANO_SECONDS_PER_SECOND){*clock_shared_memory+=1;*(clock_shared_memory+1)=0;}else{*(clock_shared_memory+1)+=2;}if(*clock_shared_memory==max_sim_time||num_slaves_completed==MAX_SLAVES)break;}free_shared_memory();return 0;}
static int get_clock_shared_segment_size(){return 2*sizeof(int);}static void free_shared_memory(){shmdt(clock_shared_memory);shmdt(message_shared_memory);shmctl(clock_segment_id,IPC_RMID,0);shmctl(message_segment_id,IPC_RMID,0);if(deallocate_binary_semaphore(sem_id)==-1){perror("Failed to deallocate binary semaphore");exit(1);}}static void free_shared_memory_and_abort(int s){free_shared_memory();abort();}static int setup_interrupt(){struct sigaction act;act.sa_handler=free_shared_memory_and_abort;act.sa_flags=0;return(sigemptyset(&act.sa_mask)||sigaction(SIGPROF,&act,NULL));}static int setup_interval_timer(int time){struct itimerval value;value.it_interval.tv_sec=time;value.it_interval.tv_usec=0;value.it_value=value.it_interval;return setitimer(ITIMER_PROF,&value,NULL);}static void print_help_message(char*e,int m,char*l,int r,int s){printf("Operating System Simulator\n\n");printf("Usage: ./%s\n\n",e);printf("Arguments:\n");printf(" -h  Show help.\n");printf(" -s  The maximum number of slave processes spawned. Defaults to %d.\n",m);printf(" -l  Specify the log file. Defaults to '%s'.\n",l);printf(" -t  Time in seconds master will terminate itself and all children. Defaults to %d.\n",r);printf(" -m  Simulated time in seconds master will terminate itself and all children. Defaults to %d.\n",s);}static int is_required_argument(char o){switch(o){case's':case'l':case't':case'm':return 1;default:return 0;}}static void print_required_argument_message(char o){switch(o){case's':fprintf(stderr,"Option -%c requires the number of slave processes.\n",o);break;case'l':fprintf(stderr,"Option -%c requires the name of the log file.\n",o);break;case't':fprintf(stderr,"Option -%c requires the maximum time before master will terminate itself and all its children.\n",o);break;case'm':fprintf(stderr,"Option -%c requires the maximum simulated time before master will terminate itself and all children.\n",o);break;}}static void get_shared_memory(){int s=get_clock_shared_segment_size();clock_segment_id=shmget(IPC_PRIVATE,s,IPC_CREAT|IPC_EXCL|0600);message_segment_id=shmget(IPC_PRIVATE,s,IPC_CREAT|IPC_EXCL|0600);if(clock_segment_id==-1||message_segment_id==-1){perror("Failed to get shared memory");exit(1);}}static void attach_to_shared_memory(){clock_shared_memory=(int*)shmat(clock_segment_id,0,0);message_shared_memory=(int*)shmat(message_segment_id,0,0);if(*clock_shared_memory==-1||*message_shared_memory==-1){perror("Failed to attach to shared memory");exit(1);}}static void fork_and_exec_children(int n){int i;for(i=0;i<n;i++)fork_and_exec_child();}static int allocate_binary_semaphore(key_t k,int f){return semget(k,1,f);}static int deallocate_binary_semaphore(int s){union semun i;return semctl(s,1,IPC_RMID,i);}static int initialize_binary_semaphore(int s){union semun a;unsigned short v[1];v[0]=1;a.array=v;return semctl(s,0,SETALL,a);}static void empty_message(){*message_shared_memory=0;*(message_shared_memory+1)=0;}static void fork_and_exec_child(){pid_t p=fork();if(p==-1){perror("Failed to fork");exit(1);}if(p==0){char c[12];sprintf(c,"%d",clock_segment_id);char m[12];sprintf(m,"%d",message_segment_id);char s[12];sprintf(s,"%d",sem_id);execlp("user","user",c,m,s,(char*)NULL);perror("Failed to exec");_exit(1);}}
